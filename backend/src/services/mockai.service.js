// src/services/mockai.service.js

function guessLangFromName(name = "") {
  const n = name.toLowerCase();
  if (n.endsWith(".ts") || n.endsWith(".tsx")) return "typescript";
  if (n.endsWith(".js") || n.endsWith(".jsx")) return "javascript";
  if (n.endsWith(".py")) return "python";
  if (n.endsWith(".java")) return "java";
  if (n.endsWith(".go")) return "go";
  if (n.endsWith(".cs")) return "csharp";
  if (n.endsWith(".rb")) return "ruby";
  return "text";
}

export async function generateSummaries({ files = [], repo = null, user = null } = {}) {
  const idBase = Date.now().toString(36);
  const summaries = files.slice(0, 10).map((f, i) => {
    const lang = f.language || guessLangFromName(f.path || f.name || "");
    return {
      id: `${idBase}-${i + 1}`,
      title: `Test: ${f.path || f.name}`,
      framework: lang === "python" ? "pytest" : lang === "java" ? "junit" : lang === "csharp" ? "nunit" : lang === "go" ? "go_testing" : lang === "ruby" ? "rspec" : "jest",
      language: lang,
      brief: `Covers core behaviors for ${f.path || f.name} including happy-path, error handling, and edge conditions.`,
      targets: [{ path: f.path || f.name, language: lang }],
    };
  });

  if (files.length > 1) {
    summaries.unshift({
      id: `${idBase}-group`,
      title: "Integration: selected files",
      framework: "jest",
      language: "javascript",
      brief: `End-to-end test covering interactions across ${files.length} files.`,
      targets: files.map((f) => ({ path: f.path || f.name, language: guessLangFromName(f.path || f.name) })),
    });
  }
  return summaries;
}

export async function generateTestCode({ summaryId, files, framework }) {
  const first = files.find(f => f.path === summaryId) || files[0] || {};
  const lang = first.language || guessLangFromName(first.path || first.name || "");
  const fw = framework || (lang === "python" ? "pytest" : lang === "java" ? "junit" : lang === "csharp" ? "nunit" : lang === "go" ? "go_testing" : lang === "ruby" ? "rspec" : "jest");

  let filename = "";
  let code = "";

  if (fw === "jest") {
    filename = `__tests__/auto-${summaryId}.test.js`;
    code = `// Auto-generated by AI (mock)
// Summary: ${summaryId}
import { describe, it, expect } from '@jest/globals';

describe('Auto ${summaryId}', () => {
  it('should do the thing (happy path)', () => {
    expect(true).toBe(true);
  });

  it('should handle edge case', () => {
    expect(() => { /* edge */ }).not.toThrow();
  });
});
`;
  } else if (fw === "pytest") {
    filename = `tests/test_auto_${summaryId}.py`;
    code = `# Auto-generated by AI (mock)
# Summary: ${summaryId}

def test_happy_path():
    assert True

def test_edge_case():
    try:
        pass
    except Exception:
        assert False
`;
  } else if (fw === "junit") {
    filename = `src/test/java/Auto${summaryId}Test.java`;
    code = `// Auto-generated by AI (mock)
// Summary: ${summaryId}
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class Auto${summaryId}Test {
    @Test
    void happyPath() { assertTrue(true); }

    @Test
    void edgeCase() { assertDoesNotThrow(() -> {}); }
}
`;
  } else if (fw === "nunit") {
    filename = `Tests/Auto${summaryId}Tests.cs`;
    code = `// Auto-generated by AI (mock)
// Summary: ${summaryId}
using NUnit.Framework;

[TestFixture]
public class Auto${summaryId}Tests
{
    [Test]
    public void HappyPath()
    {
        Assert.IsTrue(true);
    }

    [Test]
    public void EdgeCase()
    {
        Assert.DoesNotThrow(() => { });
    }
}`;
  } else if (fw === "go_testing") {
    filename = `auto_${summaryId}_test.go`;
    code = `// Auto-generated by AI (mock)
// Summary: ${summaryId}
package main

import "testing"

func TestHappyPath(t *testing.T) {
	// TODO: Implement happy path test logic
}

func TestEdgeCase(t *testing.T) {
	// TODO: Implement edge case test logic
}`;
  } else if (fw === "rspec") {
    filename = `spec/auto_${summaryId}_spec.rb`;
    code = `# Auto-generated by AI (mock)
# Summary: ${summaryId}

require 'rspec'

RSpec.describe "Auto ${summaryId}" do
  it "should handle the happy path" do
    # TODO: Implement happy path test logic
    expect(true).to be true
  end

  it "should handle edge cases" do
    # TODO: Implement edge case test logic
    expect {}.not_to raise_error
  end
end
`;
  } else {
    filename = `tests/auto-${summaryId}.txt`;
    code = `# Auto-generated test (mock)\nSummary: ${summaryId}\n`;
  }

  return { filename, code, language: lang };
}

export async function generateChatResponse(prompt) {
  // Simulate AI response for chatbot
  const responses = [
    {
      message: "I can help you improve your test cases! Here are some suggestions:",
      suggestedCode: `// Enhanced test with better assertions
describe('Improved Test Suite', () => {
  it('should handle edge cases', () => {
    expect(() => functionUnderTest(null)).toThrow();
  });
  
  it('should validate input parameters', () => {
    expect(functionUnderTest('valid')).toBeDefined();
  });
});`,
      recommendations: [
        "Add edge case testing",
        "Include input validation tests",
        "Test error scenarios"
      ],
      coverage: "Good coverage of happy path, needs edge cases",
      missingTests: ["Null input handling", "Boundary conditions"],
      suggestions: ["Add more assertions", "Test error conditions"]
    }
  ];

  // Return a random response for variety
  return responses[Math.floor(Math.random() * responses.length)];
}
